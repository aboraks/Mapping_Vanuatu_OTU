---
title: "Untitled"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
Here is a function used for this scripts 
It makes a little bracket for the violin plots at the end of the script.
```{r}
stat_box_data <- function(y, upper_limit = max(un.gr.gen$Range) * 1.15) {
  return( 
    data.frame(
      y = 0.97 * upper_limit,
      label = paste('count =', length(y), '\n',
                    'mean =', round(mean(y), 2),'\n',
                    'median =', round(median(y), 2), '\n')#,
                    #'sd =', round(sd(y), 2), '\n',)
    )
  )
}
```
heres some library packages that may be handy 
```{r}
library(sp)
library(gstat)
library(reshape2)
library(viridis)
library(automap)
suppressPackageStartupMessages({
  library(dplyr) # for "glimpse"
  library(ggplot2)
  library(scales) # for "comma"
  library(magrittr)
})
```
Check to see if there is a directory that can hold all the generated results. If not, make one
```{r}
dir.create(file.path("./", "Generated.Results"), showWarnings = FALSE)
```


#Parameters
These parameters are going to to control outliers and garbage variograms
#Outliers
Some of the estimated ranges are really big!! For example most OTU range sizes are in around 3 meters 
Several ranges are extimated at several kilometers. Their variograms seem robust, but their really throwing the analysis and figures
#garbage variograms
a lot of auto-generated variograms were bad models
It turns out most of these bad models were estimating really small ranges (<1 m). Since our minimum sampling distance was 3.3 m, it's hard to imagine a model infering smaller distances than what we sampled

So we'll remove:
really big [CCC]
and 
reallu small [DDD]
models. CCC and DDD are in meters
```{r}
CCC=13#meters
DDD=1#meter 

```

##The data used in this first loop was generated in code titled:
/Users/fungi/Google Drive/Projects/Vanuatu/Vanuatu Molecular/New_Analysis/R/Mapping.Single.Species.KriegLoop
That code generate a zillion maps and csv files for various iterations of "minimum occurence" of an otu/transect 


For the manuscript we landed on a min occurance of 2
(QQQ = 2)


This first loop perfomes wilcox test comparing the differnce in range size between 
specialists 
among
Soil:Phyllosphere 

The generated table reads as follows:

Transect___ p-value 
```{r}
# Specialists #
for (BBB in 2:24) {
  take.a.look <- read.csv(file = paste("/Users/fungi/Google Drive/Projects/Vanuatu/Vanuatu Molecular/New_Analysis/R/Mapping.single.sp/Mantel.0.05/Maps/",BBB,"otu.range.habitat.csv"), header = TRUE)
  take.a.look <- take.a.look[complete.cases(take.a.look), ] # remove the NA's
  #take.a.look <- take.a.look[take.a.look$Range>DDD,] # remove garbage variograms (you can also take a look at the maps in the corresponding directory)
  #take.a.look <- take.a.look[take.a.look$Range<CCC,] # some ranges are really big
  print(c(BBB,wilcox.test(Range ~ Habitat, data = take.a.look, exact = FALSE)$p.value))
}
```
We decide that we would like to investigate the minimum occurance of QQQ(or BBB) = 2

This will give us a nicer table of differences between the two habitas 
```{r}
BBB=2 #min occur
take.a.look <- read.csv(file = paste("/Users/fungi/Google Drive/Projects/Vanuatu/Vanuatu Molecular/New_Analysis/R/Mapping.single.sp/Mantel.0.05/Maps/",BBB,"otu.range.habitat.csv"), header = TRUE)
take.a.look <- take.a.look[complete.cases(take.a.look), ] # remove the NA's
#take.a.look <- take.a.look[take.a.look$Range>DDD,] # remove garbage variograms (you can also take a look at the maps in the corresponding directory)
#take.a.look <- take.a.look[take.a.look$Range<CCC,] # there are three OTU with large ranges - This is what they look like -> take.a.look[take.a.look$Range>30,]
spec <- take.a.look
# this is the table you will want to use for publication 
#take.a.look # OTU / Range / Habitat / Max.abun / Species
take.a.look %>%
  group_by(Habitat) %>%
  summarise(
    median = median(Range),
    mean =mean(Range),
    sd = sd(Range),
    n = n(),
    min.range = min(Range),
    max.range = max(Range)
  )
wilcox.test(Range ~ Habitat, data = take.a.look, exact = FALSE)$p.value
```

#Generalists
Now run the same two loops (as above) but for generalists




Which min occurence number is significantly different between
Generalists 
among
Soil:Phyllosphere 

```{r}
# Generalists #
for (BBB in 2:30) { # which occupancy has significant p-values 
  take.a.look <- read.csv(file = paste("/Users/fungi/Google Drive/Projects/Vanuatu/Vanuatu Molecular/New_Analysis/R/Mapping.single.sp/Mantel.0.05/Maps/",BBB,"otu.range.habitat.generalist.csv"), header = TRUE)
#  take.a.look <- take.a.look[take.a.look$Range>DDD,] # remove garbage variograms (you can also take a look at the maps in the corresponding directory)
#  take.a.look <- take.a.look[take.a.look$Range<CCC,]
  print(c(BBB,wilcox.test(Range ~ Habitat, data = take.a.look, exact = FALSE)$p.value))
}
```

```{r}

BBB=2 #min occur
take.a.look <- read.csv(file = paste("/Users/fungi/Google Drive/Projects/Vanuatu/Vanuatu Molecular/New_Analysis/R/Mapping.single.sp/Mantel.0.05/Maps/",BBB,"otu.range.habitat.generalist.csv"), header = TRUE)
take.a.look <- take.a.look[complete.cases(take.a.look), ] # remove the NA's
#take.a.look <- take.a.look[take.a.look$Range>DDD,] # remove garbage variograms (you can also take a look at the maps in the corresponding directory)
#take.a.look <- take.a.look[take.a.look$Range<CCC,]# there are three OTU with large ranges - This is what they look like -> take.a.look[take.a.look$Range>30,]
genr <- take.a.look
#take.a.look # OTU / Range / Habitat / Max.abun / Species
take.a.look %>%
  group_by(Habitat) %>%
  summarise(
    median = median(Range),
    mean =mean(Range),
    sd = sd(Range),
    n = n(),
    min.range = min(Range),
    max.range = max(Range)
  )
```

```{r}
wilcox.test(Range ~ Habitat, data = take.a.look, exact = FALSE)$p.value




# now you have two datasets that are either specialists or generalists
spec$SG <- "Specialist"
genr$SG <- "Generalist"
# add a id tag and combine 
un.gr.gen <- rbind(spec,genr)


un.gr.gen %>%
  group_by(SG) %>%
  summarise(
    median = median(Range),
    mean =mean(Range),
    sd = sd(Range),
    n = n(),
    min.range = min(Range),
    max.range = max(Range)
  )



# check for normality 
shapiro.test(spec$Range)
shapiro.test(genr$Range)
# For the both datasets p < 0.05 suggesting strong evidence of non-normality and a nonparametric test should be used


wilcox.test(Range ~ Habitat, data = spec, exact = FALSE)$p.value
wilcox.test(Range ~ Habitat, data = genr, exact = FALSE)$p.value
wilcox.test(Range ~ Habitat, data = un.gr.gen, exact = FALSE)$p.value

un.gr.gen$group <- paste(un.gr.gen$Habitat,un.gr.gen$SG)
```

Now were going to remove Outliers, Bad-Variograms 
and run a pairwise wilcox test - adjusting for multiple hypothesis testing 

```{r}
CCC=13 #meters
DDD=1  #meter 
un.gr.gen.spec <- un.gr.gen
un.gr.gen <- un.gr.gen[un.gr.gen$Range>DDD,]
print(paste(nrow(un.gr.gen),"/",nrow(un.gr.gen.spec),"OTUs retained because their ranges were greater than",DDD,"meters"))
un.gr.gen <- un.gr.gen[un.gr.gen$Range<CCC,]
print(paste(nrow(un.gr.gen.spec[un.gr.gen.spec$Range<CCC,]),"/",nrow(un.gr.gen.spec),"OTUs retained because their ranges were greater than",CCC,"meters"))
print(paste("After getting rid of outliers and bad variograms",nrow(un.gr.gen),"/",nrow(un.gr.gen.spec),"OTUs remain"))

pairwise.wilcox.test(un.gr.gen$Range,un.gr.gen$group,p.adjust.method = "BH")

```
Here are two csv tables used for reference. One of them will be published as a reference table. 
This table details all variograms including Outliers and bad Variograms 
```{r}
write.table(un.gr.gen.spec, file = paste("./Generated.Results/AllVariograms.csv"), sep = ",", quote = FALSE, row.names = F)
```
And this table has the OTUs used in the violin plot
```{r}
write.table(un.gr.gen.spec, file = paste("./Generated.Results/AllVariograms_OutliersBadRemoved.csv"), sep = ",", quote = FALSE, row.names = F)
```


Make a plot
```{r, echo=FALSE, warning=FALSE}
# set the order you'd like
un.gr.gen$group <- factor(un.gr.gen$group , levels=c("Understory Specialist", "Ground Specialist", "Understory Generalist", "Ground Generalist"))
# annotation
anno <- data.frame(x1 = 1.1, x2 = 1.9, y1 = 8, y2 = 8.5, xstar = 1.5, ystar = 8.7, lab = "***", SG = "Specialist")
# change labels to more appropriate names 
levels(un.gr.gen$Habitat)[match("Understory",levels(un.gr.gen$Habitat))] <- "Phyllosphere"
levels(un.gr.gen$Habitat)[match("Ground",levels(un.gr.gen$Habitat))] <- "Soil"



ggplot(un.gr.gen, aes(x = Habitat, y = Range, fill=Habitat)) +
  geom_violin() + 
  stat_summary(fun.data = stat_box_data, # this is linked to the home-made function at the top 
               geom = "text", # and places the locations of mean/median/n
               hjust = 0.5,
               vjust = 0.6) +
  stat_summary(fun.y = mean, 
               fun.ymin = mean, 
               fun.ymax = mean, 
               geom = "crossbar", 
               width = 0.3)+
  geom_jitter(shape=16, size=.3, position=position_jitter(0.3))+
  scale_x_discrete(name = "") + 
  scale_y_continuous(name = "OTU patch radius size (m)", limits = c(1,15)) +
  scale_fill_grey(start = 0.4, end = 0.9) +
  facet_grid(. ~ SG) +
  geom_text(data = anno, aes(x = xstar,  y = ystar, label = lab,fill=NULL),family = "Times") +
  geom_segment(data = anno, aes(x = x1, xend = x1, 
                                y = y1, yend = y2,fill=NULL),
               colour = "black") +
  geom_segment(data = anno, aes(x = x2, xend = x2, 
                                y = y1, yend = y2,fill=NULL),
               colour = "black") +
  geom_segment(data = anno, aes(x = x1, xend = x2, 
                                y = y2, yend = y2,fill=NULL),
               colour = "black")+
  theme(panel.background = element_rect(fill = "white", colour = "black"),
        strip.background = element_rect(fill = "white", colour = "black"),
        legend.key = element_blank(),
        legend.position = "none",
        legend.title = element_blank(),
        strip.text.x = element_text(size=12, face="bold"))
```
Save the plot
```{r}
ggsave("./Generated.Results/OTU range size.pdf", plot = last_plot(), device = NULL, path = NULL,
       scale = 1, width = 180, height = 100, units = "mm", 
       dpi = 300, limitsize = TRUE)

```
